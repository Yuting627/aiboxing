<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>JARVIS HUD — AR Experience</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
    body { font-family: 'Share Tech Mono', monospace; color: #0ff; }

    /* Full-screen webcam */
    #video-container { position: fixed; inset: 0; z-index: 0; }
    #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    #video-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 1; }

    /* Three.js globe canvas - left center, size grows with zoom to fill screen */
    #globe-canvas { position: fixed; left: 8%; top: 50%; transform: translateY(-50%); width: 28vmin; height: 28vmin; z-index: 2; pointer-events: none; transition: width 0.15s, height 0.15s, left 0.15s, top 0.15s, transform 0.15s; }
    #globe-canvas.globe-fullscreen { left: 0; top: 0; transform: none; width: 100vw; height: 100vh; }
    #globe-canvas.has-pointer { pointer-events: auto; }

    /* HUD - follows head, offset to the right */
    #hud { position: fixed; left: 50%; top: 50%; transform: translate(80px, -60px); z-index: 3; width: 320px; max-width: 85vw; will-change: transform; transition: transform 0.12s ease-out; }
    #hud .hud-panel {
      position: relative;
      background: linear-gradient(135deg, rgba(0,20,40,0.92) 0%, rgba(0,10,30,0.95) 100%);
      border: 1px solid rgba(0, 255, 255, 0.35);
      border-radius: 8px;
      box-shadow: 0 0 24px rgba(0, 255, 255, 0.12), inset 0 1px 0 rgba(255,255,255,0.06);
      padding: 14px 18px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    #hud .hud-panel::before {
      content: ''; position: absolute; inset: -1px; border-radius: 9px; padding: 1px;
      background: linear-gradient(135deg, rgba(0,255,255,0.4), transparent 40%, transparent 60%, rgba(0,255,255,0.2));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
      pointer-events: none;
    }
    .hud-title { color: rgba(0, 255, 255, 0.9); margin-bottom: 10px; font-weight: 600; font-size: 10px; }
    .hud-row { display: flex; justify-content: space-between; margin-bottom: 6px; color: rgba(0, 255, 255, 0.75); }
    .hud-row .value { color: #0ff; font-weight: 500; }
    .hud-row .value.warn { color: #ff0; }
    .hud-divider { height: 1px; background: linear-gradient(90deg, transparent, rgba(0,255,255,0.3), transparent); margin: 10px 0; }
    .scanline { position: absolute; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, rgba(0,255,255,0.6), transparent); animation: scan 2s linear infinite; pointer-events: none; }
    @keyframes scan { 0% { top: 0; } 100% { top: 100%; } }

    /* Start screen */
    #start-screen { position: fixed; inset: 0; z-index: 10; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px;
      padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); }
    #start-screen.hidden { display: none; }
    #start-screen h1 { font-family: 'Orbitron', sans-serif; font-size: clamp(1.5rem, 4vw, 2.2rem); color: #0ff; margin-bottom: 8px; letter-spacing: 0.2em; }
    #start-screen p { color: rgba(0,255,255,0.7); font-size: 14px; margin-bottom: 24px; text-align: center; max-width: 420px; }
    #start-btn { font-family: 'Orbitron', sans-serif; padding: 14px 32px; font-size: 14px; letter-spacing: 0.15em; background: linear-gradient(180deg, rgba(0,255,255,0.25), rgba(0,255,255,0.1)); border: 1px solid #0ff; color: #0ff; cursor: pointer; border-radius: 6px; transition: box-shadow 0.2s, transform 0.2s; }
    #start-btn:hover { box-shadow: 0 0 20px rgba(0,255,255,0.4); transform: scale(1.02); }
    #start-btn:active { transform: scale(0.98); }
    #start-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    #load-error { color: #f88; font-size: 13px; margin-top: 12px; max-width: 360px; text-align: center; }
  </style>
</head>
<body>
  <div id="start-screen">
    <h1>JARVIS HUD</h1>
    <p>AR 风格抬头显示。允许摄像头后，移动头部 — HUD 会跟随。单手移动可旋转地球，捏合手势可缩放。支持手机浏览器，需使用 HTTPS 或 localhost。</p>
    <button id="start-btn">启用摄像头并开始</button>
    <div id="load-error" aria-live="polite"></div>
  </div>

  <div id="video-container">
    <video id="webcam" autoplay playsinline muted></video>
    <div id="video-overlay"></div>
  </div>

  <canvas id="globe-canvas"></canvas>

  <div id="hud">
    <div class="scanline"></div>
    <div class="hud-panel">
      <div class="hud-title">System status</div>
      <div class="hud-row"><span>Core</span><span class="value">Online</span></div>
      <div class="hud-row"><span>Power</span><span class="value" id="metric-power">--%</span></div>
      <div class="hud-row"><span>Defense</span><span class="value">Active</span></div>
      <div class="hud-divider"></div>
      <div class="hud-row"><span>Location</span><span class="value" id="metric-loc">--</span></div>
      <div class="hud-row"><span>Time</span><span class="value" id="metric-time">--:--:--</span></div>
      <div class="hud-row"><span>FPS</span><span class="value" id="metric-fps">--</span></div>
    </div>
  </div>

  <script type="module">
    const video = document.getElementById('webcam');
    const hud = document.getElementById('hud');
    const globeCanvas = document.getElementById('globe-canvas');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const loadError = document.getElementById('load-error');

    function showLoadError(msg) {
      loadError.textContent = msg || '加载失败';
      startBtn.disabled = false;
      startBtn.textContent = '重试';
    }

    function clearLoadError() {
      loadError.textContent = '';
    }

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.maxTouchPoints > 0;

    const HUD_OFFSET_X = 80;
    const HUD_OFFSET_Y = -60;

    let faceLandmarker = null;
    let handLandmarker = null;
    let visionModule = null;
    let lastFaceX = 0.35;
    let lastFaceY = 0.5;
    let globeRotationY = 0;
    let globeRotationX = 0.2;
    let globeScale = 1;
    let lastPinchDist = 0;
    let lastHandX = 0.5;
    let lastHandY = 0.5;
    let frameCount = 0;
    let lastFpsTime = performance.now();
    let animationId = null;

    async function initMediaPipe() {
      const { FilesetResolver, FaceLandmarker, HandLandmarker } = visionModule;
      const vision = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm'
      );
      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task' },
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrix: false,
        runningMode: 'VIDEO',
        numFaces: 1
      });
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task' },
        runningMode: 'VIDEO',
        numHands: 2
      });
    }

    function updateHudPosition(normX, normY) {
      lastFaceX = 0.85 * lastFaceX + 0.15 * normX;
      lastFaceY = 0.85 * lastFaceY + 0.15 * normY;
      const x = lastFaceX * window.innerWidth + HUD_OFFSET_X;
      const y = lastFaceY * window.innerHeight + HUD_OFFSET_Y;
      hud.style.left = `${Math.max(20, Math.min(window.innerWidth - 340, x))}px`;
      hud.style.top = `${Math.max(20, Math.min(window.innerHeight - 260, y))}px`;
      hud.style.transform = 'none';
    }

    function updateMetrics() {
      frameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        document.getElementById('metric-fps').textContent = frameCount;
        frameCount = 0;
        lastFpsTime = now;
      }
      const d = new Date();
      document.getElementById('metric-time').textContent = d.toTimeString().slice(0, 8);
      document.getElementById('metric-power').textContent = Math.round(92 + Math.random() * 8) + '%';
      const locs = ['Malibu', 'Stark Tower', 'Lab 7', 'HQ'];
      document.getElementById('metric-loc').textContent = locs[Math.floor(d.getSeconds() / 15) % locs.length];
    }

    function detectFrame() {
      if (!video.videoWidth || !faceLandmarker || !handLandmarker) return;
      const ts = performance.now();
      try {
        const faceResult = faceLandmarker.detectForVideo(video, ts);
        if (faceResult.faceLandmarks && faceResult.faceLandmarks[0]) {
          const lm = faceResult.faceLandmarks[0];
          const nose = lm[1];
          const left = lm[234];
          const right = lm[454];
          const cx = (nose.x + (left.x + right.x) / 2) / 2;
          const cy = nose.y;
          updateHudPosition(cx, cy);
        }
      } catch (_) {}

      try {
        const handResult = handLandmarker.detectForVideo(video, ts);
        if (handResult.landmarks && handResult.landmarks.length > 0) {
          const hand = handResult.landmarks[0];
          const thumbTip = hand[4];
          const indexTip = hand[8];
          const palm = hand[9];
          const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
          if (pinchDist < 0.08) {
            if (lastPinchDist > 0) {
              const delta = pinchDist - lastPinchDist;
              globeScale = Math.max(0.2, globeScale - delta * 18);
            }
            lastPinchDist = pinchDist;
          } else {
            lastPinchDist = 0;
            const dx = palm.x - lastHandX;
            const dy = palm.y - lastHandY;
            globeRotationY += dx * 5;
            globeRotationX = Math.max(-0.8, Math.min(0.8, globeRotationX + dy * 4));
            lastHandX = palm.x;
            lastHandY = palm.y;
          }
        } else {
          lastHandX = 0.5;
          lastHandY = 0.5;
        }
      } catch (_) {}
    }

    function tick() {
      detectFrame();
      updateMetrics();
      updateGlobe();
      animationId = requestAnimationFrame(tick);
    }

    let scene, camera, renderer, globeMesh;
    function initGlobe() {
      const THREE = globalThis.THREE;
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.z = 4;
      renderer = new THREE.WebGLRenderer({ canvas: globeCanvas, alpha: true, antialias: true });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      const geometry = new THREE.SphereGeometry(1, 32, 24);
      const material = new THREE.MeshBasicMaterial({
        color: 0x001a33,
        wireframe: true,
        transparent: true,
        opacity: 0.85
      });
      globeMesh = new THREE.Mesh(geometry, material);
      scene.add(globeMesh);
      const latLine = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.RingGeometry(0.98, 1, 32)),
        new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 })
      );
      latLine.rotation.x = Math.PI / 2;
      globeMesh.add(latLine);
      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
    }

    function resizeGlobe() {
      const w = globeCanvas.clientWidth;
      const h = globeCanvas.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    function updateGlobe() {
      if (!globeMesh || !renderer) return;
      globeMesh.rotation.y = globeRotationY;
      globeMesh.rotation.x = globeRotationX;
      globeMesh.scale.setScalar(globeScale);
      const sizeVmin = Math.min(28 * globeScale, 100);
      if (globeScale >= 100 / 28) {
        globeCanvas.style.width = '';
        globeCanvas.style.height = '';
        globeCanvas.classList.add('globe-fullscreen');
      } else {
        globeCanvas.classList.remove('globe-fullscreen');
        globeCanvas.style.width = sizeVmin + 'vmin';
        globeCanvas.style.height = sizeVmin + 'vmin';
      }
      resizeGlobe();
      renderer.render(scene, camera);
    }

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      clearLoadError();
      startBtn.textContent = '加载中…';
      try {
        const videoOpts = isMobile
          ? { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' }
          : { width: 1280, height: 720 };
        const stream = await navigator.mediaDevices.getUserMedia({ video: videoOpts });
        video.srcObject = stream;
        await video.play();
      } catch (e) {
        showLoadError('无法访问摄像头：' + (e.message || '请允许使用摄像头'));
        return;
      }
      startBtn.textContent = '加载模型中…';
      try {
        if (!visionModule) {
          const mod = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/vision_bundle.mjs');
          visionModule = mod.FaceLandmarker ? mod : (mod.default || mod);
          if (!visionModule || !visionModule.FaceLandmarker) {
            throw new Error('MediaPipe 模块格式异常');
          }
        }
        if (!globalThis.THREE) {
          await new Promise((res, rej) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js';
            script.crossOrigin = 'anonymous';
            script.onload = res;
            script.onerror = () => rej(new Error('Three.js 加载失败'));
            document.head.appendChild(script);
          });
        }
        await initMediaPipe();
        initGlobe();
        startScreen.classList.add('hidden');
        startBtn.disabled = false;
        startBtn.textContent = '启用摄像头并开始';
        tick();
      } catch (e) {
        console.error(e);
        showLoadError('模型加载失败: ' + (e.message || String(e)));
      }
    });
  </script>
</body>
</html>
